<!--
	作者：Sariay
	时间：2018-09-25
	描述：There may be a bug, but don't worry, QiLing(器灵) says that it can work normally!
-->
<!DOCTYPE html>
<html class="html-loading">
		

<head><meta name="generator" content="Hexo 3.8.0">
	<meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
  <title>
    
      关于二叉树、递归、DFS、BFS | 偏安一隅，自言自语
    
  </title>
  <meta name="author" content="Alicekeke">
  <meta name="keywords" content>
  <meta name="description" content>
	<!-- favicon -->
  <link rel="shortcut icon" href="/img/favicon.ico">

  <!-- css -->
  <link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="/css/Annie.css">
  
  <!-- jquery -->
	<script src="/js/jquery.min.js"></script>

  <!-- leancloud -->
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
<script src="/js/leancloud.js"></script>
</head>
	<body>
		<!-- Preloader -->

	<div id="preloader">
		<div class="pre-container">
			
				<div class="spinner">
					<div class="double-bounce1"></div>
					<div class="double-bounce2"></div>
				</div>
						
		</div>
	</div>


<!-- header -->
<header class="fixbackground" data-img-mode="normal" data-normal-src="https://source.unsplash.com/collection/954550/1920×1080" data-random-max="110" data-random-src="https://sariay.github.io/Random-img/">
	<div class="mask">
		<!-- Logo and navigation -->
		<div class="h-header">
			<div id="logo">
				<a href="/">
						
						<img src="/img/logo1.png" alt="Logo">
					
				</a>
			</div>
			
			<div id="navigation-show">
				<ul>
	
		<li class="menu-home">
			<a href="/" class="menu-item-home">主页</a>
		</li>
	
		<li class="menu-archive">
			<a href="/archives" class="menu-item-archive">归档</a>
		</li>
	
		<li class="menu-categories">
			<a href="/categories" class="menu-item-categories">分类</a>
		</li>
	
		<li class="menu-tags">
			<a href="/tags" class="menu-item-tags">标签</a>
		</li>
	
		<li class="menu-about">
			<a href="/about" class="menu-item-about">关于</a>
		</li>
	
		<li class="menu-gallery">
			<a href="/gallery" class="menu-item-gallery">相册</a>
		</li>
	

	
		<li class="menu-search">
			<a href="javascript:;" class="popup-trigger">搜索</a>
		</li>
	
</ul>
			</div>				
		</div>

		<!-- motto -->
		<div class="h-body">	
			
				<p class="motto"></p>
			
		</div>
		
		<!-- others: such as time... -->			
		<div class="h-footer">
			<a href="javascript:;" id="read-more"><i class="fa fa-angle-double-down" aria-hidden="true"></i>
			</a>

			
				<!-- 
	This is only a demo, please go to "https://time.is" to set your city time! 
-->
<style type="text/css">
	.header-date {
		font-size: 1.6rem;
		color: #fff;
		position: absolute;
		bottom: 5px;
		right: 1rem;
		writing-mode: tb-rl;
	}	
	
	.header-date a {
		border-bottom: none;
	}

	@media only screen and (max-width: 768 ) {
		.header-date {
			font-size: 1rem;
		}			
	}
</style>
<div class="header-date">
	<a href="https://time.is/Beijing" id="time_is_link" rel="nofollow"></a>
	<span id="Beijing_z43d"></span>
</div>
<script src="//widget.time.is/zh.js"></script>
<script>
	time_is_widget.init({
		Beijing_z43d:{
			template:"DATE", 
			date_format:"year年 monthname dnum日"
		}
	});
</script>
			
		</div>
	</div>
</header>

<div id="navigation-hide">
	<!-- Progress bar -->
	<div id="progress-bar"></div>

	<!-- Progress percent -->
	<div id="progress-percentage"><h1>0.0%</h1></div>

	<div class="toc-switch"><span class="switch-button">目录</span></div>

	<!-- Page title -->
	<p>
		
			当前文章&nbsp;:&nbsp;《关于二叉树、递归、DFS、BFS》
		
	</p>

	<!-- Nav trigger for navigation-H-->
	<a class="nav-trigger"><span></span></a>
</div>

<!-- Navigation in div(id="navigation-H") -->
<nav class="nav-container" id="cd-nav">
	<div class="nav-header">
		<h3>Navigation</h3>
		<a href="javascript:;" class="nav-close"></a>
	</div>
	<div class="nav-body">
		<ul>
	
		<li class="menu-home">
			<a href="/" class="menu-item-home">主页</a>
		</li>
	
		<li class="menu-archive">
			<a href="/archives" class="menu-item-archive">归档</a>
		</li>
	
		<li class="menu-categories">
			<a href="/categories" class="menu-item-categories">分类</a>
		</li>
	
		<li class="menu-tags">
			<a href="/tags" class="menu-item-tags">标签</a>
		</li>
	
		<li class="menu-about">
			<a href="/about" class="menu-item-about">关于</a>
		</li>
	
		<li class="menu-gallery">
			<a href="/gallery" class="menu-item-gallery">相册</a>
		</li>
	

	
		<li class="menu-search">
			<a href="javascript:;" class="popup-trigger">搜索</a>
		</li>
	
</ul>
	</div>
	<div class="nav-footer">
		<ul>
	
		<li>
			<a href="http://github.com/Alicekeke" target="_blank">
				<i class="fa fa-github"></i>
			</a>
		</li>
	
		<li>
			<a href="http://weibo.com/u/6296111133" target="_blank">
				<i class="fa fa-weibo"></i>
			</a>
		</li>
	
		<li>
			<a href="http://github.com/" target="_blank">
				<i class="fa fa-pinterest"></i>
			</a>
		</li>
	
		<li>
			<a href="http://github.com/" target="_blank">
				<i class="fa fa-instagram"></i>
			</a>
		</li>
	
		<li>
			<a href="http://github.com/" target="_blank">
				<i class="fa fa-twitter"></i>
			</a>
		</li>
	
		<li>
			<a href="/atom.xml" target="_blank">
				<i class="fa fa-rss"></i>
			</a>
		</li>
			
</ul>

	</div>
</nav>
			
		<!--main-->
		<main>
			<!--
	时间：2018-11-17
	描述：
		插件名称：katelog.min.js
		插件作者：KELEN
		插件来源: https://github.com/KELEN/katelog
-->

	
		<div class="layout-toc">
			<div id="layout-toc">
				<div class="k-catelog-list" id="catelog-list" data-title="文章目录"></div>
			</div>
		</div>

		
		<script src="/plugin/toc/katelog.min.js"></script>

		
	 

<div class="layout-post">
	<div id="layout-post">
	<div class="article-title">
		<i class="fa fa-paper-plane-o" aria-hidden="true"></i>
		
	<a href="/2020/03/06/binaryTree/" itemprop="url">
		关于二叉树、递归、DFS、BFS
	</a>

	</div>

	<div class="article-meta">
		<span>
			<i class="fa fa-calendar"></i>
			


	发布于

	<a href="/2020/03/06/binaryTree/" itemprop="url">
		<time datetime="2020-03-06T07:29:05.032Z" itemprop="datePublished">
	  		2020-03-06
	  </time>
	</a>
	&nbsp;





			




	更新于

	<a href="/2020/03/06/binaryTree/" itemprop="url">
		<time datetime="2020-03-06T07:29:05.032Z" itemprop="dateUpdated">
	  		2020-03-06
	  </time>
	</a> 



		</span>
		<span>
			<i class="fa fa-tags"></i>
			
	
		<a href="/tags/algorithm/" class=" ">
			algorithm
		</a>
	
		
		</span>
		
		



	</div>

	<div class="article-content" id="article-content">
		<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前言：这是作为一个正在学习的前端开发者整理一下最近写的题，这文章是我对二叉树算法的浅显的理解，希望可以让你在看完文章之后对常见的二叉树操作有一定的了解，文中列举了我觉得比较经典的一些题目。有不对的地方欢迎指出。😮😮😮</p>
<blockquote>
<p>本文首发于我的博客 ：<a href="https://alicekeke.github.io/2020/03/06/binaryTree/" target="_blank" rel="noopener">https://alicekeke.github.io/2020/03/06/binaryTree/</a></p>
</blockquote>
<h2 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h2><p>树的定义：是一类重要的非线性数据结构，是以分支关系定义的层次结构。每个结点有零个或多个子结点；没有父结点的结点称为根结点；每一个非根结点有且只有一个父结点；除了根结点外，每个子结点可以分为多个不相交的子树</p>
<p>一些常见的名词解释：</p>
<ul>
<li>节点的度：一个节点含有的子树的个数称为该节点的度</li>
<li>叶子结点：没有子节点的节点</li>
<li>结点层次：从根开始定义起，根为第一层，根的孩子为第二层，以此类推</li>
<li>树的深度：树中结点的最大层次数称为树的深度或高度</li>
</ul>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="二叉树特点"><a href="#二叉树特点" class="headerlink" title="二叉树特点"></a>二叉树特点</h2><p>二叉树是每个节点最多拥有两个子节点，左子树和右子树是有顺序的不能任意颠倒。</p>
<p><strong>满二叉树</strong>：在一棵二叉树中。如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。<br><img src="http://q6csqg15o.bkt.clouddn.com/fullbinarytree.png" alt="满二叉树"></p>
<p>  <strong>完全二叉树</strong>：完全二叉树是由满二叉树而引出来的，若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数(即1~h-1层为一个满二叉树)，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树<br><img src="http://q6csqg15o.bkt.clouddn.com/fullbinarytree.png" alt="完全二叉树"><br>求解二叉树的题目，离不开递归，递归的算法框架，是很多常用算法框架的雏形；大部分算法技巧，本质上都是树的遍历问题。</p>
<h2 id="关于递归"><a href="#关于递归" class="headerlink" title="关于递归"></a>关于递归</h2><h3 id="什么是递归"><a href="#什么是递归" class="headerlink" title="什么是递归"></a>什么是递归</h3><p><strong>递归：无限调用自身这个函数，每次调用总会改动一个关键变量，直到这个关键变量达到边界的时候，不再调用。</strong></p>
<p>简单来说：就是函数不断调用函数本身，就叫递归</p>
<p>上一张我发过朋友圈的图<br><img src="http://q6csqg15o.bkt.clouddn.com/diguifx.jpg" alt="递归复习"><br>递归递归，先递过去，再归回来<br>就想这样，一个大的问题（复习）拆成很多子问题来解决，子问题不会又拆成子子问题…，（递）好不容易终于最小最小的那个子问题被解决了，这个最小最小的问题被解决，得到返回值，返回值又解决了上一层子问题，上一层的返回值又解决了上上一层的问题… 依次类推，直到最开始的问题被解决（归）。<br>所以，所以我们应该关心的是每一层递归要解决什么问题？🤔问题被解决后应当有什么返回值？🤔和当前整个递归的退出条件。</p>
<h3 id="递归的误区"><a href="#递归的误区" class="headerlink" title="递归的误区"></a>递归的误区</h3><p>我刚开始刷递归的题，摆脱不了用线性的for、while（true）去思考，想这一层函数做了什么，它调用完自身后的下一层函数又做了什么…这样很容易蒙 (ಥ_ಥ)），你都写递归了还把函数拆开来if else一步步迭代，这不是适得其反嘛，(/□＼<em>)。我们其实不用关注整个递归要走多少遍，每一遍都得出什么结果。其实既然递归是给每一层做一样的事情，就不需要把自己绕进这个递归的圈里去，*</em>我们只需要关注一级递归的解决过程即可。**。</p>
<h3 id="什么情况用递归？"><a href="#什么情况用递归？" class="headerlink" title="什么情况用递归？"></a>什么情况用递归？</h3><p>通常情况下，能被递归解决的问题具有以下两个特点：</p>
<ol>
<li>一个问题可以分解成具有相同解决思路的子问题，子子问题，换句话说这些问题都能调用同一个函数  </li>
<li>经过层层分解的子问题最后一定是有一个不能再分解的固定值的（即终止条件）,如果没有的话,就无穷无尽地分解子问题了，没有出口，死循环必定无解。</li>
</ol>
<p>在求解递归问题之前，必须通过以上两个特点验证是否能用递归求解。<br>通过判断后，我们就可以使用递归的解题模板。</p>
<h3 id="递归三部曲"><a href="#递归三部曲" class="headerlink" title="递归三部曲"></a>递归三部曲</h3><p>像我上面说的，递归之前先思考三连：每一层递归要解决什么问题？问题被解决后应当有什么返回值？当前整个递归的退出条件？</p>
<p>总结出这个递归的基本套路</p>
<ol>
<li><strong>找整个递归的终止条件：递归应该在什么时候结束？</strong></li>
<li><strong>找返回值：应该给上一级什么返回值？</strong></li>
<li><strong>本级递归应该做什么：在这一级递归中，应该完成什么任务？</strong></li>
</ol>
<p>套用这个三步曲，我们可以解决一些常见的递归问题：</p>
<p>比如经典的斐波那契数列，f[n]=f[n-1]+f[n-2]。n-1是传入参数n的前一个，n-2是最后传入参数n的前两个数字，我们每次都要让f(n-1)和f(n-2)相加得出返回值，直到找到出口f(1)f(2) 返回1。套用模板明确每一步干什么：</p>
<ol>
<li>递归的结束条件？f[1]=1，f[2]=1，就是那个最小粒度可求解的子问题，</li>
<li>该层给上一级返回什么信息？return f(n-1)+f(n-2)</li>
<li>本级递归应该完成什么任务？每层的任务都是相同的，即计算返回f[n-1]+f[n-2]。</li>
</ol>
<p>这样就可以很简单的写出斐波那契数列的递归解法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>|n==<span class="number">2</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fn(n<span class="number">-1</span>)+fn(n<span class="number">-2</span>);	</span><br><span class="line">	<span class="comment">//不断调用自身函数，n-1是传参的前一次，n-2是最后传参的前两个数字。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相信看到这，你心里多多少少对递归有个大概的了解了。<br>在刷题时，根据数据结构的不同：线性或非线性，有不同的遍历数据的方法：线性对应循环和迭代 for(while), true/false ,  非线性就要用到递归，你会发现只要的涉及递归的问题，都是树的问题，就算他的数据结构不是树，也能抽象为树。</p>
<p>先从最简单的题开始了解二叉树和递归吧。</p>
<h2 id="二叉树的各种姿势"><a href="#二叉树的各种姿势" class="headerlink" title="二叉树的各种姿势"></a>二叉树的各种姿势</h2><p>树的节点那么多，但树的节点结构都是一样的，无论多少个节点，我们可以对一个节点干的事也是一样的，如图：<br><img src="http://q6csqg15o.bkt.clouddn.com/mmexport1583479986549.jpg" alt="TreeNode"></p>
<p>结点的数据结构如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TreeNode</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.val = val;</span><br><span class="line"><span class="keyword">this</span>.left = <span class="keyword">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据递归设计出二叉树算法的普适方法，明确一个结点要做的事情，剩下的交给这个通用方法。</p>
<p>基本上所有的树都可以抽象成这样</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> traverse = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">	<span class="comment">//这里写root要做什么，具体的代码</span></span><br><span class="line">	<span class="comment">//剩下节点怎么办，交给同一个方法。</span></span><br><span class="line">	traverse (root.left)</span><br><span class="line">	traverse (root.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>树的遍历有很明显的分治的思想，因为很常见这样的代码👇</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">traverse (root.left)	<span class="comment">//看左边</span></span><br><span class="line">traverse (root.right)	<span class="comment">//看右边</span></span><br></pre></td></tr></table></figure>

<p>二叉树的所有问题都可以被分成看左边（左树）和看右边（右树）两种情况，逐个解决。<br>类似于我们常见的二分（low，high）也是像这样把问题分成一半一半来求解。直到被分割的规模缩小到容易解决。</p>
<h3 id="一些常见的二叉树算法题"><a href="#一些常见的二叉树算法题" class="headerlink" title="一些常见的二叉树算法题"></a>一些常见的二叉树算法题</h3><p>先来一个最简单的</p>
<h4 id="怎样把二叉树的所有结点加一"><a href="#怎样把二叉树的所有结点加一" class="headerlink" title="怎样把二叉树的所有结点加一"></a>怎样把二叉树的所有结点加一</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> plusOne= <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">	root.val += <span class="number">1</span>;	<span class="comment">//当前root要做的操作</span></span><br><span class="line">	plusOne (root.left);</span><br><span class="line">	plusOne (root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是这样对左右树轮到的节点做一样的加一操作，树空（null）退出循环。</p>
<h4 id="比较两个树是否相等"><a href="#比较两个树是否相等" class="headerlink" title="比较两个树是否相等"></a>比较两个树是否相等</h4><p><a href="https://leetcode-cn.com/problems/same-tree/" target="_blank" rel="noopener">LeetCode链接</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isSameTree = <span class="function"><span class="keyword">function</span>(<span class="params">p, q</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p &amp;&amp; !q) <span class="keyword">return</span>  <span class="literal">true</span>;	<span class="comment">//都为空，显然相同</span></span><br><span class="line">  <span class="keyword">if</span>(!p || !q) <span class="keyword">return</span>  <span class="literal">false</span>;	<span class="comment">//一个为空，一个非空，不同步，显然不同</span></span><br><span class="line">  <span class="keyword">if</span>(q.val !== p.val) <span class="keyword">return</span>  <span class="literal">false</span>;	<span class="comment">//结点value不一样，不同</span></span><br><span class="line"><span class="comment">//上面即要对每个节点做的操作，返回值是true|false，接下来就是递归判断左右树</span></span><br><span class="line">  <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right); <span class="comment">//p,q 两个子树，分别比较两个子树</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个树的相等性判断不需要改变树的value，只需要把所有让树不相等的情况列出，排除返回false，最后返回一个boolean值即可。</p>
<h4 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h4><p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/" target="_blank" rel="noopener">LeetCode链接</a></p>
<p>套用解题模板：</p>
<ol>
<li><strong>找终止条件。</strong>  什么情况下递归结束？树为空（null），递归结束。</li>
<li><strong>找返回值。</strong>  应该返回什么？返回当前交换左右子树后的节点</li>
<li><strong>本级递归应该做什么。</strong>  交换后重置当前的左右子树，即调用同一个交换函数，返回交换后的节点，重置原二叉树。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mirrorTree = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 交换当前节点的左右节点，再递归的交换当前节点的左节点，递归的交换当前节点的右节点 null返回</span></span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="comment">//交换结点</span></span><br><span class="line">    <span class="keyword">let</span> temp = root.left</span><br><span class="line">    root.left = root.right</span><br><span class="line">    root.right = temp</span><br><span class="line">    <span class="comment">// 重复对左右子树做一样的操作，并重置root</span></span><br><span class="line">    root.left = mirrorTree(root.left)</span><br><span class="line">    root.right = mirrorTree(root.right)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="求二叉树最大深度"><a href="#求二叉树最大深度" class="headerlink" title="求二叉树最大深度"></a>求二叉树最大深度</h4><p><a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">LeetCode链接</a></p>
<p>套用解题模板：</p>
<ol>
<li><strong>找终止条件。</strong>  什么情况下递归结束？树为空（null），递归结束。</li>
<li><strong>找返回值。</strong>  应该返回什么？题目求的是树的最大深度，我们需要根据每一层遍历到的深度+1，返回左右子树的深度最大值。</li>
<li><strong>本级递归应该做什么。</strong>  首先，还是强调要走出之前的思维误区，每个节点就三个可操作的值：root、root.left、root.right，其中根据第二步，left和right分别记录的是root的左右子树的最大深度。我们在每一次遍历到新的节点更新这个值，然后再返回left和right中较大的那个深度即可。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(root === <span class="literal">null</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">let</span> lefth = maxDepth(root.left)</span><br><span class="line">	<span class="keyword">let</span> righth = maxDepth(root.right)</span><br><span class="line">	<span class="keyword">return</span>  <span class="built_in">Math</span>.max(lefth, righth) + <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个时候我们发现，上面这两题都只有一个返回值，并且这个返回值在遍历节点的过程中一直在更新，如果二叉树涉及到全局的变量，比如最短、最优，不止判断当前单个的二叉树节点，而是判断全局二叉树是否满足某条件，return一个返回值明显不够的，现在该怎么办呢？</p>
<h2 id="借助helpFunction"><a href="#借助helpFunction" class="headerlink" title="借助helpFunction"></a>借助helpFunction</h2><p>helpFunction是将功能独立出来的一个函数，在题目较为复杂时，一个返回值不能满足我们的需求，我们需要多一些变量来记录当前的值，来保证这个值能在相对于全局而固定，不会在每一次遍历结点时被更新。这个时候就需要helpFunction来增加参数列表，定义返回值接口，在返回值中携带更多有用的信息。</p>
<p>这个概念类似于函数式编程中的组合参数，它能将一个函数调用的输出路由到另一个函数的调用上，然后一直进行下去。是一种声明式抽象，以获取更多的信息。</p>
<h4 id="验证平衡二叉树"><a href="#验证平衡二叉树" class="headerlink" title="验证平衡二叉树"></a>验证平衡二叉树</h4><p><a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">LeetCode链接</a></p>
<p>最典型的是104题 验证平衡二叉树（Balanced Binary Tree简称AVL）<br><img src="http://q6csqg15o.bkt.clouddn.com/mmexport1583479984234.jpg" alt="BSTandAVL"></p>
<blockquote>
<p>平衡二叉树的定义：<br>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p>
</blockquote>
<p>这个时候我们光记录当前的高度已经不够了，因为它不仅仅要求我们当前左右子树高度差不超过1，整个树的高度差都不能超过1。</p>
<p>所以我们至少需要两个返回值：</p>
<ol>
<li>当前结点高度</li>
<li>当前结点是否是平衡二叉树</li>
</ol>
<p>如果当前结点不是平衡二叉树，那剩下的还遍历个啥 = = ，直接返回false就行了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isBalanced = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 传任意结点，返回当前节点的高度</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">height</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (node === <span class="literal">null</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//叶子结点，返回null</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">let</span> h = <span class="built_in">Math</span>.max(height(node.left), height(node.right)) + <span class="number">1</span>; <span class="comment">//递归 在左右子树选较大高度值，加一即当前结点高度</span></span><br><span class="line">     <span class="keyword">return</span> h;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//该树没有任何叶子结点，即为平衡二叉树</span></span><br><span class="line">   <span class="comment">// 判断高度差绝对值是否超过1，且要递归判断每个节点的子树</span></span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">Math</span>.abs(height(root.left) - height(root.right)) &lt; <span class="number">2</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right)</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p>这里用到的<code>height</code>函数就是helpFunction。 helpFunction根据你具体要做的事命名。宏观上它的作用就是提供更多有用参数的辅助函数。</p>
<p>为了理解helpFunction的作用，我们来看更多的实现场景：</p>
<h4 id="二叉树的层次遍历"><a href="#二叉树的层次遍历" class="headerlink" title="二叉树的层次遍历"></a>二叉树的层次遍历</h4><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">LeetCode链接</a></p>
<p>题目描述：给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。<br>例如<br>       3<br>   / /<br>  9  20<br>    /  /<br>   15   7<br>   返回[ [3],[9,20],  [15,7] ]</p>
<p>这里很明显需要借助helpFunction，因为我们最后返回的肯定是一个数组，但当前遍历是按层次遍历，节点自身只能操作自己的左右子树，所以必然需要一个函数来记录当前层次的节点，保存为一维数组；记录当前的层数与总层数比较，来向下进级。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的层次遍历</span></span><br><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> levels = []	<span class="comment">//最后返回总的二维数组</span></span><br><span class="line">  <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">    <span class="keyword">return</span> levels	<span class="comment">//空树返回空数组</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">walk</span>(<span class="params">node, level</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(levels.length === level) &#123;<span class="comment">//新的层级</span></span><br><span class="line">      levels.push([])</span><br><span class="line">    &#125;</span><br><span class="line">    levels[level].push(node.val)	<span class="comment">//保存当前结点</span></span><br><span class="line">    <span class="keyword">if</span>(node.left) &#123;</span><br><span class="line">      walk(node.left, level + <span class="number">1</span>)	<span class="comment">//level+1 向下层遍历</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node.right) &#123;</span><br><span class="line">      walk(node.right, level + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  walk(root, <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> levels;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断二叉搜索树（BST）"><a href="#判断二叉搜索树（BST）" class="headerlink" title="判断二叉搜索树（BST）"></a>判断二叉搜索树（BST）</h4><p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">LeetCode链接</a></p>
<p>二叉搜索树（简称BST）是很常用的二叉树，其定义是：一个二叉树中，任意节点的值要大于左子树所有结点的值，且要小于等于右边子树所有结点的值：<br>如图就是应该符合定义的BST<br><img src="http://q6csqg15o.bkt.clouddn.com/mmexport1583479984234.jpg" alt="BST"></p>
<p>和AVL树同理，当前结点root要做的不仅仅是左右结点比较，而是整个左子树和右子树所有结点进行比较，单单一个返回值肯定不够了，这个时候就要设计一个helpFunction</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isValidBST = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> inOrderList = [];</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">inOrder</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">		inOrder(node.left);	<span class="comment">//判断左树</span></span><br><span class="line">		inOrderList.push(node.val);</span><br><span class="line">		inOrder(node.right);  <span class="comment">//判断右树</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从根节点开始遍历 返回结点数组</span></span><br><span class="line">	inOrder(root)</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; inOrderList.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="comment">// 确保遍历出的结点是递增 ==&gt; 平衡树</span></span><br><span class="line">		<span class="keyword">if</span> (inOrderList[i] &gt;= inOrderList[i + <span class="number">1</span>]) &#123; <span class="comment">//考虑结点相等的情况！</span></span><br><span class="line">		<span class="keyword">return</span>  <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">return</span>  <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>看到这里，你应该学会以下几个技巧</p>
<ol>
<li>二叉树算法的原则，把当前节点要做的事做好，其他交给递归框架，不用当前节点操心</li>
<li>如果当前节点会对下面的子节点有整体影响，可以通过helpFunction辅助函数设计返回值接口，携带更多的参数传递信息。</li>
<li>BST和AVL树的验证方法   </li>
</ol>
<h2 id="引申BFS-和-DFS"><a href="#引申BFS-和-DFS" class="headerlink" title="引申BFS 和 DFS"></a>引申BFS 和 DFS</h2><p>前文中我说过：任何非线性的数据结构，涉及到递归的问题，都是树的问题，就算他的数据结构不是树，也能抽象为树。接下来，我们就稍稍讨论下按深度优先和广度优先求解图的问题，同样的思想，同样的方法。</p>
<h3 id="深度优先策略"><a href="#深度优先策略" class="headerlink" title="深度优先策略"></a>深度优先策略</h3><p>首先明确下概念</p>
<blockquote>
<p>深度优先搜索算法（Depth First Search，简称DFS）：一种用于遍历或搜索树或图的算法。 沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过或者在搜寻时结点不满足条件，搜索将回溯到发现节点v的那条边的起始节点。整个进程反复进行直到所有节点都被访问为止。属于盲目搜索,最糟糕的情况算法时间复杂度为O(!n)。</p>
</blockquote>
<p>来源<a href="[https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2](https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2)">wiki 深度优先搜索</a></p>
<p>回溯法：是一种选优搜索法，又称为试探法<br><img src="http://q6csqg15o.bkt.clouddn.com/9150e4e5ly1fm8iugfxzbj20j60czjs5.jpg" alt="在危险的边缘疯狂试探"><br><img src="http://q6csqg15o.bkt.clouddn.com/814268e3ly1fmxw116vosj20i20i23zp.jpg" alt="试探之后"></p>
<p>关键在于，<strong>不合适就退回上一步</strong></p>
<p>回溯法常见的解题模板</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">backtrack</span>(<span class="params">路径, 选择列表</span>):</span></span><br><span class="line"><span class="function">    <span class="title">if</span> 满足结束条件:</span></span><br><span class="line"><span class="function">        <span class="title">result</span>.<span class="title">add</span>(<span class="params">路径</span>)</span></span><br><span class="line"><span class="function">        <span class="title">return</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="title">for</span> 选择 <span class="title">of</span> 选择列表:</span></span><br><span class="line"><span class="function">        做选择</span></span><br><span class="line"><span class="function">        <span class="title">backtrack</span>(<span class="params">路径, 选择列表</span>)</span></span><br><span class="line"><span class="function">        撤销选择</span></span><br></pre></td></tr></table></figure>

<p> 但与此同时，最坏的情况下，回溯的时间复杂度会变大，所以要用到<strong>剪枝</strong>来提速。<strong>剪枝</strong>就是在搜索过程中利用<strong>过滤条件</strong>来剪去完全不用考虑（已经判断这条路走下去得不到最优解）的搜索路径，从而避免了一些不必要的搜索。剪枝这个形容非常的形象，想象一下，春天来了 花匠大叔会把树向下长的枝干全部剪掉，留下向上的。这就是剪枝。</p>
<p>如果具体问解的个数，问最优、最先、最短，一般来讲用dp来做，问所有的解的集合 就用DFS</p>
<p>DFS模板</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result： 所有结果集</span><br><span class="line">list： 当前的单个解	（result和list会在DFS的过程中不断更新）</span><br><span class="line">pos：记录当前处理的位置</span><br><span class="line">visited：结点有无访问状态（求最优路径）</span><br><span class="line">if(condition) 退出条件</span><br></pre></td></tr></table></figure>

<p>举一道medium难度的dfs题做例子</p>
<h4 id="所有合法括号集合"><a href="#所有合法括号集合" class="headerlink" title="所有合法括号集合"></a>所有合法括号集合</h4><p><a href="https://leetcode-cn.com/problems/bracket-lcci/" target="_blank" rel="noopener">LeetCode链接</a></p>
<p>题目描述：设计一种算法，打印n对括号的所有合法的（例如，开闭一一对应）组合。且解集不能包含重复的子集。<br>例如，给出 n = 3，生成结果为：</p>
<blockquote>
<p>[  “((()))”, “(()())”, “(())()”, “()(())”,”()()()”  ]</p>
</blockquote>
<p> 这题很明显要返回所有有效括号的解的集合，helpFuncton （题解中的DFS）要返回的返回值接口包括（当前剩余的左括号，剩余的右括号，当前加入合法的左/右括号，结果的集合）。并且只有两种情况，加入当前list或者不加.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">left, right, list, result</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(left === <span class="number">0</span> &amp;&amp; right === <span class="number">0</span>)&#123; <span class="comment">// 左右括号都为0，退出条件</span></span><br><span class="line">		result.push(list)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// dfs只有两种情况，加入list或不加，提前判断加入括号是否有效</span></span><br><span class="line">	<span class="keyword">if</span>(left &gt; <span class="number">0</span>)&#123; <span class="comment">//左括号无所谓增加 有就放</span></span><br><span class="line">		dfs(left - <span class="number">1</span>, right, list + <span class="string">'('</span>, result) <span class="comment">//放入哪边括号 剩余n -1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//已有的左括号&gt;右括号才能放入，即剩下的左括号&lt;右括号</span></span><br><span class="line">	<span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">		dfs(left, right - <span class="number">1</span>, list + <span class="string">')'</span>, result)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> generateParenthesis = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> result = [];</span><br><span class="line">	<span class="keyword">let</span> list = <span class="string">''</span>;</span><br><span class="line">	<span class="comment">// 已知n，不需要记录当前visited来判断退出条件</span></span><br><span class="line">	dfs(n, n, <span class="string">''</span>, result);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这题因为给出了终止条件，即n对括号，凑满了就不用再判断，所以不需要记录判断当前visited。并且这里在判断valid时用到剪枝的思想：因为有些DFS是把所有情况的解都产生之后，在判断退出条件的时候再判断是否valid；但我们在加入当前list之前就判断左右括号是否valid，满足才放进result，这样就保证在长度（n）合适退出循环的时候，拿到的result都是有效的解。</p>
<h3 id="广度优先策略"><a href="#广度优先策略" class="headerlink" title="广度优先策略"></a>广度优先策略</h3><p>BFS: 从根节点出发，沿着树的宽度，每次都访问同一层的节点，若同一层都访问完，再访问下一层，若所有的节点均被访问，则算法终止，最后BFS找到的路径即为最短路径。</p>
<p>BFS相对于DFS，DFS是一条路走到底，没有先后顺序，BFS按层级遍历，好记录当前遍历层级，更利于求最优路径。</p>
<h4 id="腐烂的橘子"><a href="#腐烂的橘子" class="headerlink" title="腐烂的橘子"></a>腐烂的橘子</h4><p><a href="https://leetcode-cn.com/problems/rotting-oranges/" target="_blank" rel="noopener">LeetCode链接</a></p>
<p>题目描述：在给定的网格中，可能有三个值：0 代表空单元格； 1 代表新鲜橘子； 2 代表腐烂的橘子。<br>每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。</p>
<p>腐烂的橘子应该是N皇后问题的简易版，这里不需要返回解集，求最小time，并且每个橘子都朝着每层的四个方向腐烂，层级优先，考虑BFS</p>
<p>没有用到递归。plan：枚举 + BFS</p>
<p>解读一下题目，映射到BFS的概念上：<br>    - 四个方向相邻 ——&gt; 访问同一层节点<br>    - 污染四个方向上的节点 ——&gt; 对每个坏橘为基进行BFS<br>    - 最短路径 ——&gt; 最短腐烂时间</p>
<p>还是原来的那个模板，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result： 所有结果集</span><br><span class="line">list： 当前的单个解	（result和list会在DFS的过程中不断更新）</span><br><span class="line">pos：记录当前处理的位置</span><br><span class="line">visited：结点有无访问状态（求最优路径）</span><br><span class="line">if(condition) 退出条件</span><br></pre></td></tr></table></figure>

<p>list记录当前坏橘的坐标和最后需要返回的经过时间,二维坐标记录当前要前进的方向</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> orangesRotting = <span class="function"><span class="keyword">function</span>(<span class="params">grid</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 1. 初始化坏橘坐标，好橘个数，经过时间，</span></span><br><span class="line">	<span class="keyword">let</span> time = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">let</span> result = [];</span><br><span class="line">	<span class="keyword">let</span> foc = <span class="number">0</span>; <span class="comment">//fresh orange count = 0</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;grid.length; i++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>; j&lt;grid[i].length; j++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(grid[i][j] === <span class="number">2</span>) result.push([i, j ,<span class="number">0</span>])</span><br><span class="line">		<span class="keyword">if</span>(grid[i][j] === <span class="number">1</span>) foc++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">console</span>.log(result, foc)</span><br><span class="line">	<span class="comment">// 开始遍历队列中的坏橘</span></span><br><span class="line">	<span class="keyword">while</span>(result.length)&#123;</span><br><span class="line">		<span class="keyword">let</span> cur = result.shift();</span><br><span class="line">		<span class="built_in">console</span>.log(cur)</span><br><span class="line">		time = cur[<span class="number">2</span>];<span class="comment">//腐烂时间</span></span><br><span class="line">		rotting(cur[<span class="number">0</span>], cur[<span class="number">1</span>], cur[<span class="number">2</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 处理腐烂感染过程</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">rotting</span>(<span class="params">row, col, time</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">let</span> direction = [[<span class="number">-1</span>,<span class="number">0</span>], [<span class="number">0</span>,<span class="number">1</span>], [<span class="number">1</span>,<span class="number">0</span>], [<span class="number">0</span>,<span class="number">-1</span>]]; <span class="comment">//先四	个方向（广度）遍历</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">let</span> d=<span class="number">0</span>; d&lt;<span class="number">4</span>; d++)&#123;</span><br><span class="line">		<span class="keyword">let</span> r = row + direction[d][<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">let</span> c = col + direction[d][<span class="number">1</span>]; <span class="comment">//当前坐标向四个方向移动</span></span><br><span class="line">		<span class="comment">// 在gird内且是新鲜可感染的橘子，置2; 否则continue</span></span><br><span class="line">		<span class="keyword">if</span>(r&lt;<span class="number">0</span> || r&gt;=grid.length || c&lt;<span class="number">0</span> || c&gt;=grid[<span class="number">0</span>].length || grid[r][c] !== <span class="number">1</span>) &#123;<span class="keyword">continue</span>&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		grid[r][c] = <span class="number">2</span>;</span><br><span class="line">		foc --;</span><br><span class="line">		result.push([r, c, time+<span class="number">1</span>])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最后所有橘子都一定会坏,否则就没有坏橘</span></span><br><span class="line"><span class="keyword">return</span> foc &gt; <span class="number">0</span> ? <span class="number">-1</span> : time</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我好想回学校宿舍拿我数据结构的书，书上很多笔记和图例，可我困在家里出不去😥😥😥</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>看完本文你将会了解递归、分治、剪枝、回溯、枚举、DFS、BFS等基本算法思想的基本思想及使用。</li>
<li>掌握常见二叉树题型的解法即思路。</li>
<li>文章很长，一万多字加图文，大家可以点个赞收藏一下，马了慢慢看。</li>
<li>在社区潜水这么久，很感谢掘金上的大佬们的技术分享，一路走来帮助我这个还在学校的小白学到了很多，也希望自己能写出好的文章回馈社区，总结自己最近学到的东西能帮助到一起学习的掘友们。掘金大佬如云，我这样的小白发文也是诚惶诚恐。如果我写的有啥不对的欢迎大家在评论区告诉我呀，期待和大家一起交流~🤣🤣🤣</li>
</ul>
	
	</div>
	
	<div id="current-post-cover" data-scr="/img/post-cover/1.jpg"></div>

	<!-- relate post, comment...-->
	<div class="investment-container">
		<div class="investment-header">
			<div class="investment-title-1">
				<div class="on">相关文章</div>
				<div>评论</div>
				<div>分享</div>
			</div>
			<div class="investment-title-2">	            
				
	<span>
		<a href="javascript: window.scrollTo(0, 0);">返回顶部</a>
		
			<a href="/2020/03/19/03.19daily/" title="我的三月碎碎念" rel="prev">
				&laquo;上一篇
			</a>
		
		
			<a href="/2020/02/27/OMG_list/" title="李佳琦可视化list" rel="next">
				下一篇&raquo;
			</a>
			
	</span>


      		
			</div>	
		</div>
		
		<div class="investment-content">
			<div class="investment-content-list">
				

<div class="relate-post">
	
		<ul>
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2020/03/19/03.19daily/" title="我的三月碎碎念">
								我的三月碎碎念			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								三月 19日, 2020				
							</p>
							<p class="relate-post-content">
								前言现在三月中旬了，是待在家为祖国做贡献的第二个月，不在学校的日子，每天在家学习，也过的蛮充实。少了很多社交，昨天还和谷歌娘唠嗑些有的没的。每天的小结越写越短，那就这一次给自己写个阶段性的总结吧。    
基础  这段时间赶上春招，社...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2020/03/19/03.19daily/" title="我的三月碎碎念">				
								
								<img class="lazy" src="/img/placeholder.jpg" data-src="/img/post-cover/2.jpg" alt="我的三月碎碎念">
							</a>
						</div>
					</li>											
			
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2020/02/27/OMG_list/" title="李佳琦可视化list">
								李佳琦可视化list			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								二月 27日, 2020				
							</p>
							<p class="relate-post-content">
								前言做这个李佳琦推荐口红可视化倒也不是因为自己喜欢买口红或者喜欢看李佳琦，是一次在车上逛微博看到热搜上一个帖子，很详细的整理了这些口红，用手机自带的备忘录写的，但略显简陋，颜色展示仅仅是在色号后面加了个很小的色卡，当时就想，如果可以做...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2020/02/27/OMG_list/" title="李佳琦可视化list">				
								
								<img class="lazy" src="/img/placeholder.jpg" data-src="/img/post-cover/4.jpg" alt="李佳琦可视化list">
							</a>
						</div>
					</li>											
			
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2020/01/22/coffeewxapp/" title="给阿姨倒一杯卡布奇诺">
								给阿姨倒一杯卡布奇诺			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								一月 22日, 2020				
							</p>
							<p class="relate-post-content">
								前言图床老挂， 在掘金看吧，阅读体验更好 👉看这里
平安夜那天晚上下课打着伞想到的idea做出来了，写个总结
页面结构12345678&quot;pages&quot;: [  &quot;pages/buy/buy&quot;, ...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2020/01/22/coffeewxapp/" title="给阿姨倒一杯卡布奇诺">				
								
								<img class="lazy" src="/img/placeholder.jpg" data-src="/img/post-cover/1.jpg" alt="给阿姨倒一杯卡布奇诺">
							</a>
						</div>
					</li>											
			
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2019/11/10/cloneShallow-cloneDeep/" title="深拷贝与浅拷贝">
								深拷贝与浅拷贝			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								十一月 10日, 2019				
							</p>
							<p class="relate-post-content">
								数据类型数据分为基本数据类型(String, Number, Boolean, Null, Undefined，Symbol)和对象数据类型    
原始数据类型：保存在栈(stack)中，引用类型类型：存储的是该对象在栈中引用，真实...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2019/11/10/cloneShallow-cloneDeep/" title="深拷贝与浅拷贝">				
								
								<img class="lazy" src="/img/placeholder.jpg" data-src="/img/post-cover/3.jpg" alt="深拷贝与浅拷贝">
							</a>
						</div>
					</li>											
			
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2019/07/30/es6note/" title="es6 note">
								es6 note			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								七月 30日, 2019				
							</p>
							<p class="relate-post-content">
								1.ES6怎么来的
ECMAScript 和 JavaScriptECMA 是标准，JS 是实现ECMAScript 简称 ECMA 或 ES


历史版本1996, ES1.0 Netscape 将 JS 提交给 ECMA 组织，E...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2019/07/30/es6note/" title="es6 note">				
								
								<img class="lazy" src="/img/placeholder.jpg" data-src="/img/post-cover/es6.jpg" alt="es6 note">
							</a>
						</div>
					</li>											
			
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2019/06/03/a02/" title="傲慢与偏见 Mr.Darcy">
								傲慢与偏见 Mr.Darcy			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								六月 3日, 2019				
							</p>
							<p class="relate-post-content">
								淋雨的自杀式告白– Miss Elizabeth , I have struggled in vain and can bear it      no longer. These past months have been a tor...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2019/06/03/a02/" title="傲慢与偏见 Mr.Darcy">				
								
								<img class="lazy" src="/img/placeholder.jpg" data-src="/img/post-cover/darcy1.jpg" alt="傲慢与偏见 Mr.Darcy">
							</a>
						</div>
					</li>											
			
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2019/06/02/a01/" title="随笔杂谈">
								随笔杂谈			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								六月 2日, 2019				
							</p>
							<p class="relate-post-content">
								关于《胜利之光》如果你正在经历挫折与失败，心灰意冷时，一定要看看这部电影
以后你可能再也找不到能让你这么热血拼搏的事情了趁现在你还有热血，趁现在你还有激情去做那些只要想到就会让你两眼放光的事情吧因为过了这段时间，你可能再也难以找到那种...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2019/06/02/a01/" title="随笔杂谈">				
								
								<img class="lazy" src="/img/placeholder.jpg" data-src="/img/post-cover/2.jpg" alt="随笔杂谈">
							</a>
						</div>
					</li>											
			
			
					<li>
						<div class="relate-post-text">
							<a class="relate-post-title" href="/2019/06/02/hello-world/" title="Hello World">
								Hello World			
							</a>
							<p class="relate-post-date">
								<i class="fa fa-calendar"></i>
								六月 2日, 2019				
							</p>
							<p class="relate-post-content">
								Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using ...
							</p>
						</div>

						<div class="relate-post-cover">
							<a href="/2019/06/02/hello-world/" title="Hello World">				
								
								<img class="lazy" src="/img/placeholder.jpg" data-src="/img/2.jpg" alt="Hello World">
							</a>
						</div>
					</li>											
			
			
		</ul>
	
</div>	
			</div>
			<div class="investment-content-list">
				<div class="layout-comment">

	

		

			<!-- I don't know !!!-->
			<div>Please check the comment setting in config.yml of hexo-theme-Annie!</div>
			
		
		
	

</div>
			</div>
			<div class="investment-content-list">
				<div class="layout-share">
	
	

		
			
			<!-- socialShare share -->
			<div class="social-share"></div>

<!--  css & js -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">
<script async src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>
			
		
		
	
</div>


			</div>
		</div>	
	</div>
	</div>
</div>



	<!-- leancloud -->
	<!--
	时间：2018-11-27
	描述：
		文章访问量：visitors
		文章喜欢量：likes	
		文章排行榜：topNPost
		其他得说明：
			01-Cookie相关的函数 
				https://blog.csdn.net/somehow1002/article/details/78511541（Author：somehow1002）
			02-visitors相关的函数 
				https://blog.csdn.net/u013553529/article/details/63357382（Author：爱博客大伯）
				https://notes.doublemine.me/2015-10-21-为NexT主题添加文章阅读量统计功能.html（Author：夏末）
			03-topNPost相关的函数
				https://hoxis.github.io/hexo-next-read-rank.html（Author：hoxis）
			04-likes相关的函数，
				参考了01 & 02进行简单的设计与实现
-->


	


<!-- show math formula -->



	 
	<script src="/plugin/clipboard/clipboard.js"></script>
	<script>
		// Copy code !
	    function codePreprocessing() {
	        $("#article-content .highlight").each(function() {

	            $(this).wrap('<div id="post-code"></div>');

	        })

	        $("#article-content #post-code").each(function() {

	            $(this).prepend('<nav class="copy-nav"><span><i class="code-language"></i></span></nav>');

	        })

	        $("#article-content .copy-nav").each(function() {
	            var temp = $(this).next().attr('class'),
	                language = ((temp.length > 9) && (temp != null)) ? temp.substr(10) : "none"; //why 9? Need to check language?

	            $(this).find('.code-language').text(language);

	            $(this).append('<span class="copy-btn"><i class="fa fa-copy" aria-hidden="true"></i></span>');

	        });
	    }

		function codeCopy() {
		    $('#article-content #post-code').each(function(i) {
		        var codeCopyId = 'codeCopy-' + i;

		        var codeNode = $(this).find('.code'),
		            copyButton = $(this).find('.copy-btn');

		        codeNode.attr('id', codeCopyId);
		        copyButton.attr('data-clipboard-target-id', codeCopyId);
		    })

		    
			var clipboard = new ClipboardJS('.copy-btn', {
					target: function(trigger) {
						return document.getElementById(trigger.getAttribute('data-clipboard-target-id'));
					}
		      	});

			//pure js
			function showTooltip(elem, msg) {		   
				elem.setAttribute('aria-label', msg);
				elem.setAttribute('class', 'copy-btn copy-status');
				setTimeout(function() {
					elem.setAttribute('class', 'copy-btn');
				}, 2000);
			}

			clipboard.on('success', function(e) {
			    e.clearSelection();
			    console.info('Action:', e.action);		   
			    console.info('Trigger:', e.trigger);
			    showTooltip(e.trigger, 'Copied!');
			    
			});
			clipboard.on('error', function(e) {
			    console.error('Action:', e.action);
			    console.error('Trigger:', e.trigger);
			});
		

		}

		if ($('.layout-post').length) {
		    codePreprocessing();
		    codeCopy();
		} 
	</script>





<link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">
<script src="/plugin/fancybox/jquery.fancybox.js"></script>

<script type="text/javascript">
	var titleID = $('.article-title a'),
		imageID = $('.article-content img'),
		videoID = $('.article-content video');

	var postTitle = titleID.text() ? titleID.text() : "No post title!";

	imageID.each(function() {
		var imgPath = $(this).attr('src'),
			imgTitle = $(this).attr('alt') ? $(this).attr('alt') : "No image description!";

		//给每个匹配的<img>元素打包, 即添加父元素<a>
		$(this).wrap('<a data-fancybox="gallery" data-caption=" 《 ' + postTitle + ' 》 ' + imgTitle + ' "  href=" ' + imgPath + ' "> </a>');
	});

	videoID.each(function() {
		var videoPath = $(this).attr('src');

		//给每个匹配的<img>元素打包, 即添加父元素<a>
		$(this).wrap('<a data-fancybox href=" ' + videoPath + ' "> </a>');
	});
	//TODO：支持html5 video

	if($('#layout-post').length) {
		$('[data-fancybox="gallery"]').fancybox({
			loop: true,
			buttons: [
				"zoom",
				"share",
				"slideShow",
				"fullScreen",
				//"download",
				"thumbs",
				"close"
			],
			protect: false
		});
	}
</script>
		</main>

		<!--footer-->
		<footer>
	<div class="social">
		<ul>
	
		<li>
			<a href="http://github.com/Alicekeke" target="_blank">
				<i class="fa fa-github"></i>
			</a>
		</li>
	
		<li>
			<a href="http://weibo.com/u/6296111133" target="_blank">
				<i class="fa fa-weibo"></i>
			</a>
		</li>
	
		<li>
			<a href="http://github.com/" target="_blank">
				<i class="fa fa-pinterest"></i>
			</a>
		</li>
	
		<li>
			<a href="http://github.com/" target="_blank">
				<i class="fa fa-instagram"></i>
			</a>
		</li>
	
		<li>
			<a href="http://github.com/" target="_blank">
				<i class="fa fa-twitter"></i>
			</a>
		</li>
	
		<li>
			<a href="/atom.xml" target="_blank">
				<i class="fa fa-rss"></i>
			</a>
		</li>
			
</ul>

	</div>
		
	<div class="copyright">
		<p>
			 
				&copy;2017 - 2020, content by Alicekeke. All Rights Reserved.
			
			
			

	<!-- busuanzi -->
	<!-- busuanzi -->

		
	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	

		<span id="busuanzi_container_page_pv">
	  		本文总阅读量<span id="busuanzi_value_page_pv"></span>次
		</span>

	




		</p>
		<p>
			<a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> Theme <a href="https://github.com/Sariay/hexo-theme-Annie" title="Annie" target="_blank" rel="noopener">Annie</a> by Sariay.
			<a href="javascript:zh_tran('s');" class="zh_click" id="zh_click_s">简体</a> 
			<a href="javascript:zh_tran('t');" class="zh_click" id="zh_click_t">繁體</a>				
		</p>
	</div>		
</footer>
		
	<!-- set '1' to show motto in all pages! -->

	<script src="/plugin/motto/motto.js"></script>
	
	<script type="text/javascript">
		$(".motto").html( getMingYanContent() );
	</script>	




	<!--
	时间：2018-10-3
	描述：
		插件名称：hexo-generator-search-zip
		插件来源: https://github.com/SuperKieran/hexo-generator-search-zip
		代码参考：https://github.com/SuperKieran/TKL/blob/master/layout/_partial/search.ejs(Include: js & css)	
-->
<div class="popup search-popup local-search-popup">
	<div class="local-search-container">
		<span class="popup-btn-close">
      		ESC
   		</span>
		<div class="local-search-header">
			<div class="input-prompt">				
			</div>
			<input autocomplete="off" placeholder="Search..." type="text" id="local-search-input">
		</div>
		<div class="local-search-body">
			<div id="local-search-output"></div>
		</div>
		<div class="local-search-footer">
			<div class="topN-post">				
				
								
			</div>
		</div>
	</div>
</div>

<script src="/plugin/search/ziploader.js"></script>
<script src="/plugin/search/search.js"></script>

<script type="text/javascript">
	var search_path = 'search.json',
		zip_Path = '/search.zip',
		version_Path = '/searchVersion.txt',
		input_Trigger = 'auto',
		top_N = '2';

	themeLocalSearch({
		search_path, 
		zip_Path, 
		version_Path, 
		input_Trigger, 
		top_N
	});
</script>


<!-- love effect -->

	<script src="/plugin/love/love.js"></script>


<!-- back to top -->

	
	<div id="totop">
  		<a href="javascript:;" name="TOTOP" class="fa fa-arrow-up"></a>
	</div>




<!-- site analysis -->


	<!-- site-analysis -->
	
	
	
	
	
 

<script src="/plugin/vibrant/vibrant.js"></script>
<script src="/plugin/chinese/chinese.js"></script>
<script src="/plugin/imgLazyLoader/yall.min.js"></script>
<script src="/plugin/imgResize/jquery.resizeimagetoparent.min.js"></script>
<script src="/plugin/nicescroll/jquery.nicescroll.js"></script>
<script src="/js/resizediv.js"></script>
<script src="/js/main.js"></script>
	</body>	
</html>